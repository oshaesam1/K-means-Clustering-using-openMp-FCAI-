
#include <omp.h>
#include <stdio.h>
int size=100;
double distance(double x1, double y1, double x2, double y2)
{
    // Calculating distance
    return sqrt(pow(x2 - x1, 2)+ pow(y2 - y1, 2) * 1.0);
}

int main()
{
int threads_num = omp_get_max_threads() ;
    //reading from file line by line as charachters
    FILE* fileptr;
    char points[size][size];
    int numOfPoints=0;
  fileptr = fopen("\points.txt", "r");

    if (NULL == fileptr)
  {
    printf("can't be found!! \n");

        }
         while(fgets(points[numOfPoints], 100, fileptr)){numOfPoints++;}
    fclose(fileptr);

//Spliting line into x ,y
double myPoints[numOfPoints][2];
char  temp[100];
char  temp2[100];
int i;
  for( i = 0 ; i<numOfPoints ; i++ )
  {
  char *split = strtok(points[i], " ");
    if(split)
    {
         strcpy(temp,split);
       sscanf(temp, "%lf", & myPoints[i][0]);//convert from char to int
        }
    split = strtok(NULL, " ");

    if(split){
        strcpy(temp2,split);
       sscanf(temp2, "%lf", &myPoints[i][1]);

    }

  }

//getting a random point
double centroidX[threads_num];
double centroidY[threads_num];
double nearestx[threads_num][numOfPoints];
double nearesty[threads_num][numOfPoints];
int x;
srand(time(0));
    int r, j;
    for(i = 0; i < threads_num; i++)
    {
        r = rand()%threads_num;
        for(j = 0; j < i; j++)
        {
            if(centroidX[j] == myPoints[r][0] && centroidY[j] == myPoints[r][1])
            {
                j = -1;
                r = rand()%threads_num ;
            }

        }
        centroidX[i] = myPoints[r][0];
         centroidY[i] = myPoints[r][1];

// printf("%f -- %f \n",centroidX[i],centroidY[i]);
    }
//printf ("the two are : %lf , %lf , %lf,%lf  \n" , centroidX[0],centroidY[0],centroidX[1],centroidY[1]);
//calculate Euclidean distance for every thread
double distances[numOfPoints][threads_num];
 double min[numOfPoints];
   int assign[numOfPoints];
    int k,assigncentroid;
    int all_centroid_size[threads_num];


     double sumX[threads_num] ,sumY[threads_num],meanX[threads_num],meanY[threads_num];
     int loop=0;
     while (loop<10){
 int j;
    #pragma omp parallel private(i,j)num_threads(threads_num)
    {

        #pragma omp for schedule(static)
        for (i=0; i < numOfPoints; i++)
        {
    for(j=0;j<threads_num;j++){
            distances[i][j]=distance(centroidX[j],centroidX[j],myPoints[i][0],myPoints[i][1]);


            }


 //           printf ("IN thread %d: %lf , %lf , %lf \n" , omp_get_thread_num() , distances[i][0],distances[i][1],distances[i][2]);

        }

    }   /* end of parallel region */

    //  Get minimun  Euclidean distance for every point


for(k=0;k<numOfPoints;k++)
 {
int l;
 min[k] = distances[k][0];
 assign[k]=0;
    for (l = 0; l < threads_num; l++) {
       if(distances[k][l] <min[k])
    {
    assigncentroid=l;
    assign[k]=l;
    min[k] = distances[k][l];
  }

 }}
 int s;
 for(s=0;s<numOfPoints;s++){
  //    printf("%f , centriod %d , Points (%f , %f) \n",min[s],assign[s],myPoints[s][0],myPoints[s][1]);
 }
 //  Assigning each point to ceneteroid

int l,z,sizeCentroid;


for (z=0;z<threads_num;z++)
        {
           sizeCentroid=0;
            int t=0;
          for (l=0;l<numOfPoints;l++)
             {
             nearestx[z][l]=0;
             nearesty[z][l]=0;
            if(((int)assign[t])==z)
            {
               nearestx[z][sizeCentroid]=myPoints[l][0];
               nearesty[z][sizeCentroid]=myPoints[l][1];

              sizeCentroid++;
            }

            t++;

            }

    all_centroid_size[z]=sizeCentroid ;


    }
 int n,m;


 #pragma omp parallel private(n,m)num_threads(threads_num)
 {
  #pragma omp for schedule(static)
 for(n=0;n<threads_num;n++){

   sumX[n]=0; sumY[n]=0;

   for(m=0;m<all_centroid_size[n];m++)
   {

     sumX[n]+=nearestx[n][m];
      sumY[n]+= nearesty[n][m];
   }
meanX[n] = sumX[n]/all_centroid_size[n] ;
    centroidX[n]=meanX[n];
    meanY[n] = sumY[n]/all_centroid_size[n] ;
    centroidY[n]=meanX[n];

//printf ("IN thread %d :  mean of x = %lf ,  mean of y = %lf  \n" , omp_get_thread_num() , meanX[n], meanY[n] );
 }

 }
 loop++;
}
int  s,v,sizeOfCentroid=0;
for(s=0;s<threads_num;s++){
       sizeOfCentroid =all_centroid_size[s];
       printf("Points of Cluster %d : \n", s+1);


for (v=0;v<sizeOfCentroid;v++){
      printf(" ( %f , %f ) \n ",nearestx[s][v],nearesty[s][v]);}

}
}
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































